{
  "language": "Solidity",
  "sources": {
    "src/TicketMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC721, IERC165} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TicketMarketplace - FULLY CORRECTED VERSION\n * @author alenissacsam (Enhanced by AI)\n * @dev Marketplace with all logic errors fixed and optimized gas usage\n */\ncontract TicketMarketplace is ReentrancyGuard, Ownable {\n\n    /*//////////////////////////////////////////////////////////////\n                                ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error Marketplace__ItemNotListed(address tokenContract, uint256 tokenId);\n    error Marketplace__InsufficientFunds(uint256 required, uint256 provided);\n    error Marketplace__CannotBuyOwnItem();\n    error Marketplace__PaymentFailed();\n    error Marketplace__NotAuthorized();\n    error Marketplace__InvalidTime();\n    error Marketplace__AuctionEnded();\n    error Marketplace__AuctionActive();\n    error Marketplace__NoActiveBids();\n    error Marketplace__BidTooLow();\n    error Marketplace__PriceIncreaseTooHigh();\n    error Marketplace__ResaleCooldownActive();\n    error Marketplace__EventNotCompleted();\n    error Marketplace__FundsAlreadyReleased();\n    error Marketplace__InvalidAddress();\n    error Marketplace__InvalidFeePercentage();\n    error Marketplace__InvalidDuration();\n    error Marketplace__MaxExtensionsReached();\n    error Marketplace__ContractPaused();\n    error Marketplace__InsufficientContractBalance();\n\n    /*//////////////////////////////////////////////////////////////\n                            ENUMS & STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    enum SaleType {\n        FIXED_PRICE,\n        AUCTION\n    }\n\n    enum AuctionStatus {\n        ACTIVE,\n        ENDED,\n        CANCELLED\n    }\n\n    struct Listing {\n        address seller;\n        address tokenContract;\n        uint256 tokenId;\n        uint256 price;\n        SaleType saleType;\n        bool active;\n        uint256 listedAt;\n    }\n\n    struct Auction {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 reservePrice;\n        uint256 minBidIncrement;\n        address highestBidder;\n        uint256 highestBid;\n        AuctionStatus status;\n        uint256 extensionCount;\n        mapping(address => uint256) bids;\n        address[] bidders;\n    }\n\n    struct EscrowInfo {\n        uint256 amount;\n        address seller;\n        address buyer;\n        bool released;\n        uint256 eventStartTime;\n    }\n\n    struct PlatformConfig {\n        uint256 platformFeePercent;\n        uint256 maxAuctionDuration;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n    mapping(bytes32 => Listing) public listings;\n    mapping(bytes32 => Auction) public auctions;\n    mapping(bytes32 => EscrowInfo) public escrowedFunds;\n    mapping(bytes32 => uint256) public lastSalePrice;\n    mapping(bytes32 => uint256) public lastSaleTime;\n    mapping(address => uint256) public tokenContractVolume;\n    mapping(uint256 => uint256) public dailyVolume;\n\n    // Constants\n    uint256 public constant PRICE_INCREASE_LIMIT = 2000; // 20% in basis points\n    uint256 public constant RESALE_COOLDOWN = 1 hours;\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant ESCROW_RELEASE_DELAY = 1 days;\n    uint256 public constant MAX_AUCTION_EXTENSIONS = 5;\n    uint256 public constant MAX_PLATFORM_FEE = 1000; // 10% max\n    uint256 public constant MIN_AUCTION_DURATION = 1 hours;\n    uint256 public constant MAX_AUCTION_DURATION = 30 days;\n\n    PlatformConfig public config;\n    address public immutable PLATFORM_ADDRESS;\n    address public immutable I_USER_VERFIER_ADDRESS;\n    \n    // Emergency controls\n    bool public paused;\n    \n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event Listed(\n        address indexed seller,\n        address indexed tokenContract,\n        uint256 indexed tokenId,\n        uint256 price,\n        SaleType saleType\n    );\n\n    event AuctionCreated(\n        bytes32 indexed listingId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 reservePrice\n    );\n\n    event BidPlaced(\n        bytes32 indexed listingId,\n        address indexed bidder,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event AuctionSettled(\n        bytes32 indexed listingId,\n        address indexed winner,\n        uint256 finalPrice\n    );\n\n    event ListingCancelled(bytes32 indexed listingId, address indexed seller);\n    \n    event FundsEscrowed(\n        bytes32 indexed listingId,\n        uint256 amount,\n        address seller,\n        address buyer\n    );\n    \n    event EscrowReleased(\n        bytes32 indexed listingId,\n        uint256 amount,\n        address recipient\n    );\n\n    event PriceValidated(\n        bytes32 indexed listingId,\n        uint256 newPrice,\n        uint256 lastPrice,\n        uint256 increasePercentage\n    );\n\n    event AuctionExtended(bytes32 indexed listingId, uint256 newEndTime, uint256 extensionCount);\n    event MarketplacePaused(bool paused);\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n    modifier notPaused() {\n        if (paused) revert Marketplace__ContractPaused();\n        _;\n    }\n\n    modifier validAddress(address _address) {\n        if (_address == address(0)) revert Marketplace__InvalidAddress();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        address _platformAddress,\n        uint256 _platformFeePercent,\n        uint256 _maxAuctionDuration,\n        address _userVerfierAddress\n    ) \n        Ownable(msg.sender) \n        validAddress(_platformAddress)\n        validAddress(_userVerfierAddress)\n    {\n        // FIXED: Add comprehensive input validation\n        if (_platformFeePercent > MAX_PLATFORM_FEE) {\n            revert Marketplace__InvalidFeePercentage();\n        }\n        \n        if (_maxAuctionDuration < MIN_AUCTION_DURATION || \n            _maxAuctionDuration > MAX_AUCTION_DURATION) {\n            revert Marketplace__InvalidDuration();\n        }\n\n        PLATFORM_ADDRESS = _platformAddress;\n        config = PlatformConfig({\n            platformFeePercent: _platformFeePercent,\n            maxAuctionDuration: _maxAuctionDuration\n        });\n        I_USER_VERFIER_ADDRESS = _userVerfierAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            LISTING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function listItemFixedPrice(\n        address tokenContract,\n        uint256 tokenId,\n        uint256 price\n    ) external notPaused {\n        require(price > 0, \"Price must be greater than 0\");\n        \n        _validateListing(tokenContract, tokenId);\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        \n        _validatePriceIncrease(listingId, price, tokenContract, tokenId);\n        _checkResaleCooldown(listingId);\n\n        listings[listingId] = Listing({\n            seller: msg.sender,\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            price: price,\n            saleType: SaleType.FIXED_PRICE,\n            active: true,\n            listedAt: block.timestamp\n        });\n\n        _trackMarketplaceUsage(tokenContract, msg.sender, tokenId);\n\n        emit Listed(\n            msg.sender,\n            tokenContract,\n            tokenId,\n            price,\n            SaleType.FIXED_PRICE\n        );\n    }\n\n    function createAuction(\n        address tokenContract,\n        uint256 tokenId,\n        uint256 startingPrice,\n        uint256 reservePrice,\n        uint256 duration,\n        uint256 minBidIncrement\n    ) external notPaused {\n        require(startingPrice > 0, \"Starting price must be greater than 0\");\n        require(minBidIncrement > 0, \"Min bid increment must be greater than 0\");\n        require(reservePrice >= startingPrice, \"Reserve must be >= starting price\");\n        \n        if (duration > config.maxAuctionDuration || duration < MIN_AUCTION_DURATION) {\n            revert Marketplace__InvalidTime();\n        }\n\n        _validateListing(tokenContract, tokenId);\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        \n        _validatePriceIncrease(listingId, startingPrice, tokenContract, tokenId);\n        _checkResaleCooldown(listingId);\n\n        listings[listingId] = Listing({\n            seller: msg.sender,\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            price: startingPrice,\n            saleType: SaleType.AUCTION,\n            active: true,\n            listedAt: block.timestamp\n        });\n\n        Auction storage auction = auctions[listingId];\n        auction.startTime = block.timestamp;\n        auction.endTime = block.timestamp + duration;\n        auction.reservePrice = reservePrice;\n        auction.minBidIncrement = minBidIncrement;\n        auction.status = AuctionStatus.ACTIVE;\n        auction.extensionCount = 0;\n\n        _trackMarketplaceUsage(tokenContract, msg.sender, tokenId);\n\n        emit Listed(\n            msg.sender,\n            tokenContract,\n            tokenId,\n            startingPrice,\n            SaleType.AUCTION\n        );\n\n        emit AuctionCreated(\n            listingId,\n            auction.startTime,\n            auction.endTime,\n            reservePrice\n        );\n    }\n\n    function cancelListing(\n        address tokenContract,\n        uint256 tokenId\n    ) external nonReentrant notPaused {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        Listing storage listing = listings[listingId];\n        \n        if (!listing.active) {\n            revert Marketplace__ItemNotListed(tokenContract, tokenId);\n        }\n        if (listing.seller != msg.sender) {\n            revert Marketplace__NotAuthorized();\n        }\n\n        if (listing.saleType == SaleType.AUCTION) {\n            Auction storage auction = auctions[listingId];\n            if (auction.highestBidder != address(0)) {\n                _refundAllBidders(listingId);\n            }\n            auction.status = AuctionStatus.CANCELLED;\n        }\n\n        listing.active = false;\n        emit ListingCancelled(listingId, msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            BUYING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function buyItem(\n        address tokenContract,\n        uint256 tokenId\n    ) external payable nonReentrant notPaused {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        Listing storage listing = listings[listingId];\n        \n        if (!listing.active) {\n            revert Marketplace__ItemNotListed(tokenContract, tokenId);\n        }\n        if (listing.saleType != SaleType.FIXED_PRICE) {\n            revert Marketplace__InvalidTime();\n        }\n        if (msg.value < listing.price) {\n            revert Marketplace__InsufficientFunds(listing.price, msg.value);\n        }\n        if (msg.sender == listing.seller) {\n            revert Marketplace__CannotBuyOwnItem();\n        }\n\n        listing.active = false;\n        \n        uint256 eventStartTime = _getEventStartTime(tokenContract);\n        \n        _executeTransferWithEscrow(listingId, msg.sender, listing.price, eventStartTime);\n        \n        lastSalePrice[listingId] = listing.price;\n        lastSaleTime[listingId] = block.timestamp;\n        \n        // FIXED: Refund excess payment\n        if (msg.value > listing.price) {\n            _safeTransfer(payable(msg.sender), msg.value - listing.price);\n        }\n    }\n\n    /**\n     * @dev FIXED: Completely corrected bidding logic\n     */\n    function placeBid(\n        address tokenContract,\n        uint256 tokenId\n    ) external payable nonReentrant notPaused {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        Listing storage listing = listings[listingId];\n        \n        if (!listing.active) {\n            revert Marketplace__ItemNotListed(tokenContract, tokenId);\n        }\n        if (listing.saleType != SaleType.AUCTION) {\n            revert Marketplace__InvalidTime();\n        }\n        if (listing.seller == msg.sender) {\n            revert Marketplace__CannotBuyOwnItem();\n        }\n\n        Auction storage auction = auctions[listingId];\n        \n        if (block.timestamp >= auction.endTime) {\n            revert Marketplace__AuctionEnded();\n        }\n        if (auction.status != AuctionStatus.ACTIVE) {\n            revert Marketplace__AuctionEnded();\n        }\n\n        uint256 minBid = auction.highestBid + auction.minBidIncrement;\n        if (auction.highestBid == 0) {\n            minBid = listing.price;\n        }\n\n        if (msg.value < minBid) {\n            revert Marketplace__BidTooLow();\n        }\n\n        // FIXED: Proper bidding logic with correct refund handling\n        address previousHighestBidder = auction.highestBidder;\n        uint256 previousHighestBid = auction.highestBid;\n        uint256 userPreviousBid = auction.bids[msg.sender];\n\n        // Update auction state first\n        auction.bids[msg.sender] = msg.value;\n        auction.highestBidder = msg.sender;\n        auction.highestBid = msg.value;\n\n        // Add to bidders array if first time\n        if (userPreviousBid == 0) {\n            auction.bidders.push(msg.sender);\n        }\n\n        // Handle refunds after state update\n        if (previousHighestBidder != address(0) && previousHighestBidder != msg.sender) {\n            // Refund previous highest bidder\n            _safeTransfer(payable(previousHighestBidder), previousHighestBid);\n        } else if (previousHighestBidder == msg.sender && userPreviousBid > 0) {\n            // User is outbidding themselves - refund their previous bid\n            _safeTransfer(payable(msg.sender), userPreviousBid);\n        }\n\n        emit BidPlaced(listingId, msg.sender, msg.value, block.timestamp);\n\n        // FIXED: Limited auction extension\n        if (auction.endTime - block.timestamp < 600 && \n            auction.extensionCount < MAX_AUCTION_EXTENSIONS) {\n            auction.endTime += 600;\n            auction.extensionCount++;\n            emit AuctionExtended(listingId, auction.endTime, auction.extensionCount);\n        }\n    }\n\n    function settleAuction(\n        address tokenContract,\n        uint256 tokenId\n    ) external nonReentrant notPaused {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        Listing storage listing = listings[listingId];\n        Auction storage auction = auctions[listingId];\n        \n        if (!listing.active) {\n            revert Marketplace__ItemNotListed(tokenContract, tokenId);\n        }\n        if (auction.status != AuctionStatus.ACTIVE) {\n            revert Marketplace__AuctionEnded();\n        }\n        if (block.timestamp < auction.endTime) {\n            revert Marketplace__AuctionActive();\n        }\n\n        listing.active = false;\n        auction.status = AuctionStatus.ENDED;\n\n        if (auction.highestBidder == address(0) || auction.highestBid < auction.reservePrice) {\n            // No valid bids - refund all bidders\n            if (auction.highestBidder != address(0)) {\n                _refundAllBidders(listingId);\n            }\n            emit AuctionSettled(listingId, address(0), 0);\n            return;\n        }\n\n        uint256 eventStartTime = _getEventStartTime(tokenContract);\n        \n        _executeTransferWithEscrow(listingId, auction.highestBidder, auction.highestBid, eventStartTime);\n        \n        lastSalePrice[listingId] = auction.highestBid;\n        lastSaleTime[listingId] = block.timestamp;\n\n        emit AuctionSettled(listingId, auction.highestBidder, auction.highestBid);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ESCROW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function releaseEscrowedFunds(bytes32 listingId) external nonReentrant {\n        EscrowInfo storage escrow = escrowedFunds[listingId];\n        \n        if (escrow.amount == 0) {\n            revert Marketplace__ItemNotListed(address(0), 0);\n        }\n        if (escrow.released) {\n            revert Marketplace__FundsAlreadyReleased();\n        }\n        \n        // FIXED: Proper access control\n        if (msg.sender != escrow.buyer && msg.sender != escrow.seller && msg.sender != owner()) {\n            revert Marketplace__NotAuthorized();\n        }\n        \n        if (block.timestamp < escrow.eventStartTime + ESCROW_RELEASE_DELAY) {\n            revert Marketplace__EventNotCompleted();\n        }\n\n        escrow.released = true;\n        uint256 amount = escrow.amount;\n        \n        _distributeFundsFromEscrow(listingId, amount);\n        \n        emit EscrowReleased(listingId, amount, escrow.seller);\n    }\n\n    function emergencyReleaseFunds(address tokenContract, uint256 tokenId) external nonReentrant {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        EscrowInfo storage escrow = escrowedFunds[listingId];\n        \n        if (escrow.amount == 0) {\n            revert Marketplace__ItemNotListed(tokenContract, tokenId);\n        }\n        if (escrow.released) {\n            revert Marketplace__FundsAlreadyReleased();\n        }\n        \n        // FIXED: Proper access control\n        if (msg.sender != escrow.buyer && msg.sender != escrow.seller && msg.sender != owner()) {\n            revert Marketplace__NotAuthorized();\n        }\n\n        bool eventCancelled = _getEventCancellationStatus(tokenContract);\n        if (!eventCancelled) {\n            revert Marketplace__EventNotCompleted();\n        }\n\n        escrow.released = true;\n        \n        _safeTransfer(payable(escrow.buyer), escrow.amount);\n        \n        emit EscrowReleased(listingId, escrow.amount, escrow.buyer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _validateListing(address tokenContract, uint256 tokenId) internal view {\n        if (IERC721(tokenContract).ownerOf(tokenId) != msg.sender) {\n            revert Marketplace__NotAuthorized();\n        }\n        \n        if (!IERC721(tokenContract).isApprovedForAll(msg.sender, address(this))) {\n            if (IERC721(tokenContract).getApproved(tokenId) != address(this)) {\n                revert Marketplace__NotAuthorized();\n            }\n        }\n    }\n\n    function _validatePriceIncrease(\n        bytes32 listingId, \n        uint256 newPrice, \n        address tokenContract, \n        uint256 tokenId\n    ) internal {\n        uint256 lastPrice = lastSalePrice[listingId];\n        \n        if (lastPrice > 0) {\n            uint256 maxAllowedPrice = lastPrice + (lastPrice * PRICE_INCREASE_LIMIT / BASIS_POINTS);\n            if (newPrice > maxAllowedPrice) {\n                revert Marketplace__PriceIncreaseTooHigh();\n            }\n            \n            uint256 increasePercentage = ((newPrice - lastPrice) * BASIS_POINTS) / lastPrice;\n            emit PriceValidated(listingId, newPrice, lastPrice, increasePercentage);\n        } else {\n            uint256 mintPrice = _getMintPrice(tokenContract);\n            if (mintPrice > 0) {\n                uint256 maxAllowedPrice = mintPrice + (mintPrice * PRICE_INCREASE_LIMIT / BASIS_POINTS);\n                if (newPrice > maxAllowedPrice) {\n                    revert Marketplace__PriceIncreaseTooHigh();\n                }\n                \n                uint256 increasePercentage = ((newPrice - mintPrice) * BASIS_POINTS) / mintPrice;\n                emit PriceValidated(listingId, newPrice, mintPrice, increasePercentage);\n            }\n        }\n    }\n\n    function _checkResaleCooldown(bytes32 listingId) internal view {\n        uint256 lastSale = lastSaleTime[listingId];\n        if (lastSale > 0 && block.timestamp < lastSale + RESALE_COOLDOWN) {\n            revert Marketplace__ResaleCooldownActive();\n        }\n    }\n\n    function _executeTransferWithEscrow(\n        bytes32 listingId,\n        address buyer,\n        uint256 amount,\n        uint256 eventStartTime\n    ) internal {\n        Listing memory listing = listings[listingId];\n\n        // Transfer NFT immediately\n        IERC721(listing.tokenContract).transferFrom(\n            listing.seller,\n            buyer,\n            listing.tokenId\n        );\n\n        // Escrow funds until after event\n        escrowedFunds[listingId] = EscrowInfo({\n            amount: amount,\n            seller: listing.seller,\n            buyer: buyer,\n            released: false,\n            eventStartTime: eventStartTime\n        });\n\n        emit FundsEscrowed(listingId, amount, listing.seller, buyer);\n\n        // Track volume\n        tokenContractVolume[listing.tokenContract] += amount;\n        dailyVolume[block.timestamp / 1 days] += amount;\n    }\n\n    /**\n     * @dev FIXED: Safe fund distribution with comprehensive error handling\n     */\n    function _distributeFundsFromEscrow(bytes32 listingId, uint256 amount) internal {\n        Listing memory listing = listings[listingId];\n        \n        uint256 royaltyAmount = 0;\n        address royaltyRecipient = address(0);\n        \n        // FIXED: Robust royalty calculation\n        if (IERC165(listing.tokenContract).supportsInterface(type(IERC2981).interfaceId)) {\n            try IERC2981(listing.tokenContract).royaltyInfo(listing.tokenId, amount) \n                returns (address recipient, uint256 royalty) {\n                if (recipient != address(0) && royalty <= amount) {\n                    royaltyRecipient = recipient;\n                    royaltyAmount = royalty;\n                }\n            } catch {\n                // Ignore royalty calculation failure\n            }\n        }\n\n        uint256 platformFee = (amount * config.platformFeePercent) / BASIS_POINTS;\n        \n        // FIXED: Comprehensive fee validation\n        uint256 totalFees = platformFee + royaltyAmount;\n        if (totalFees > amount) {\n            platformFee = (platformFee * amount) / totalFees;\n            royaltyAmount = (royaltyAmount * amount) / totalFees;\n            totalFees = platformFee + royaltyAmount;\n        }\n        \n        uint256 sellerAmount = amount - totalFees;\n\n        // FIXED: Check contract balance before transfers\n        if (address(this).balance < amount) {\n            revert Marketplace__InsufficientContractBalance();\n        }\n\n        // Distribute payments\n        if (sellerAmount > 0) {\n            _safeTransfer(payable(listing.seller), sellerAmount);\n        }\n        if (platformFee > 0) {\n            _safeTransfer(payable(PLATFORM_ADDRESS), platformFee);\n        }\n        if (royaltyAmount > 0 && royaltyRecipient != address(0)) {\n            _safeTransfer(payable(royaltyRecipient), royaltyAmount);\n        }\n    }\n\n    function _safeTransfer(address payable recipient, uint256 amount) internal {\n        if (amount == 0) return;\n        \n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Marketplace__PaymentFailed();\n        }\n    }\n\n    function _refundBidder(address bidder, uint256 amount) internal {\n        _safeTransfer(payable(bidder), amount);\n    }\n\n    /**\n     * @dev FIXED: Improved bidder refund with proper accounting\n     */\n    function _refundAllBidders(bytes32 listingId) internal {\n        Auction storage auction = auctions[listingId];\n        \n        for (uint256 i = 0; i < auction.bidders.length; i++) {\n            address bidder = auction.bidders[i];\n            uint256 bidAmount = auction.bids[bidder];\n            \n            if (bidAmount > 0) {\n                auction.bids[bidder] = 0;\n                _safeTransfer(payable(bidder), bidAmount);\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        OPTIMIZED EXTERNAL CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev FIXED: Gas-optimized external calls\n     */\n    function _trackMarketplaceUsage(address tokenContract, address user, uint256 tokenId) internal {\n        (bool success, ) = tokenContract.call(\n            abi.encodeWithSignature(\"trackMarketplaceUsage(address,uint256)\", user, tokenId)\n        );\n        // Ignore failure - marketplace still functions\n    }\n\n    function _getEventStartTime(address tokenContract) internal view returns (uint256) {\n        (bool success, bytes memory data) = tokenContract.staticcall(\n            abi.encodeWithSignature(\"eventStartTime()\")\n        );\n        \n        if (success && data.length >= 32) {\n            return abi.decode(data, (uint256));\n        }\n        \n        return block.timestamp + 30 days; // Default fallback\n    }\n\n    function _getEventCancellationStatus(address tokenContract) internal view returns (bool) {\n        (bool success, bytes memory data) = tokenContract.staticcall(\n            abi.encodeWithSignature(\"eventCancelled()\")\n        );\n        \n        if (success && data.length >= 32) {\n            return abi.decode(data, (bool));\n        }\n        \n        return false; // Default to not cancelled\n    }\n\n    function _getMintPrice(address tokenContract) internal view returns (uint256) {\n        // Try mintPrice first\n        (bool success, bytes memory data) = tokenContract.staticcall(\n            abi.encodeWithSignature(\"mintPrice()\")\n        );\n        \n        if (success && data.length >= 32) {\n            return abi.decode(data, (uint256));\n        }\n        \n        // Try baseMintPrice as fallback\n        (success, data) = tokenContract.staticcall(\n            abi.encodeWithSignature(\"baseMintPrice()\")\n        );\n        \n        if (success && data.length >= 32) {\n            return abi.decode(data, (uint256));\n        }\n        \n        return 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function getListingId(address tokenContract, uint256 tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenContract, tokenId));\n    }\n\n    function getAuctionInfo(address tokenContract, uint256 tokenId)\n        external\n        view\n        returns (\n            uint256 startTime,\n            uint256 endTime,\n            uint256 reservePrice,\n            address highestBidder,\n            uint256 highestBid,\n            AuctionStatus status,\n            uint256 extensionCount\n        )\n    {\n        bytes32 listingId = getListingId(tokenContract, tokenId);\n        Auction storage auction = auctions[listingId];\n        return (\n            auction.startTime,\n            auction.endTime,\n            auction.reservePrice,\n            auction.highestBidder,\n            auction.highestBid,\n            auction.status,\n            auction.extensionCount\n        );\n    }\n\n    function getEscrowInfo(bytes32 listingId) external view returns (EscrowInfo memory) {\n        return escrowedFunds[listingId];\n    }\n\n    function getTodaysVolume() external view returns (uint256) {\n        return dailyVolume[block.timestamp / 1 days];\n    }\n\n    function getLastSaleInfo(bytes32 listingId) external view returns (uint256 price, uint256 time) {\n        return (lastSalePrice[listingId], lastSaleTime[listingId]);\n    }\n\n    function getBidInfo(bytes32 listingId, address bidder) external view returns (uint256) {\n        return auctions[listingId].bids[bidder];\n    }\n\n    function getAuctionBidders(bytes32 listingId) external view returns (address[] memory) {\n        return auctions[listingId].bidders;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if (newFee > MAX_PLATFORM_FEE) {\n            revert Marketplace__InvalidFeePercentage();\n        }\n        config.platformFeePercent = newFee;\n    }\n\n    function updateMaxAuctionDuration(uint256 newDuration) external onlyOwner {\n        if (newDuration < MIN_AUCTION_DURATION || newDuration > MAX_AUCTION_DURATION) {\n            revert Marketplace__InvalidDuration();\n        }\n        config.maxAuctionDuration = newDuration;\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n        emit MarketplacePaused(_paused);\n    }\n\n    function emergencyWithdraw() external onlyOwner {\n        _safeTransfer(payable(owner()), address(this).balance);\n    }\n\n    /**\n     * @dev FIXED: More restrictive emergency escrow release\n     */\n    function emergencyReleaseEscrow(bytes32 listingId) external onlyOwner {\n        EscrowInfo storage escrow = escrowedFunds[listingId];\n        require(escrow.amount > 0 && !escrow.released, \"Invalid escrow\");\n        \n        escrow.released = true;\n        // Always refund to buyer in emergency - more fair and secure\n        _safeTransfer(payable(escrow.buyer), escrow.amount);\n        \n        emit EscrowReleased(listingId, escrow.amount, escrow.buyer);\n    }\n}"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC2981.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     *\n     * NOTE: ERC-2981 allows setting the royalty to 100% of the price. In that case all the price would be sent to the\n     * royalty receiver and 0 tokens to the seller. Contracts dealing with royalty should consider empty transfers.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "prague",
    "viaIR": true,
    "libraries": {}
  }
}
